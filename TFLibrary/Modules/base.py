from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import six
import abc
import tensorflow as tf


@six.add_metaclass(abc.ABCMeta)
class AbstractModule(object):
    """Abstract encoder class.
       https://github.com/deepmind/sonnet/blob/master/sonnet/python/modules/base.py
    """

    def __init__(self, _sentinel=None, name=None):
        """Performs the initialisation necessary for all AbstractModule instances.

        Every subclass of AbstractModule must begin their constructor with a call to
        this constructor, i.e.

        `super(MySubModule, self).__init__(custom_getter=custom_getter, name=name)`.

        If you instantiate sub-modules in __init__ you must create them within the
        `_enter_variable_scope` context manager to ensure they are in the module's
        variable scope. Alternatively, instantiate sub-modules in `_build`.

        Args:
          _sentinel: Variable that only carries a non-None value if `__init__` was
              called without named parameters. If this is the case, a deprecation
              warning is issued in form of a `ValueError`.
          custom_getter: Callable or dictionary of callables to use as
            custom getters inside the module. If a dictionary, the keys
            correspond to regexes to match variable names. See the `tf.get_variable`
            documentation for information about the custom_getter API.
          name: Name of this module. Used to construct the Templated build function.
              If `None` the module's class name is used (converted to snake case).

        Raises:
          TypeError: If `name` is not a string.
          TypeError: If a given `custom_getter` is not callable.
          ValueError: If `__init__` was called without named arguments.
        """

        if _sentinel is not None:
            raise ValueError("Calling AbstractModule.__init__ "
                             "without named arguments is not supported.")

        if name is None:
            name = self.__class__.__name__.upper()
        elif not isinstance(name, six.string_types):
            raise TypeError("Name must be a string.")

        self._template = tf.make_template(
            name_=name,
            func_=self._build_wrapper,
            create_scope_now_=True)

        self._original_name = name
        self._unique_name = self._template.variable_scope.name.split("/")[-1]

        # Update __call__ and the object docsto enable better introspection.
        self.__doc__ = self._build.__doc__
        self.__call__.__func__.__doc__ = self._build.__doc__

        # Container for all variables created in this
        # module and its sub-modules.
        self._all_variables = set([])

    def _build_wrapper(self, *args, **kwargs):
        """Function which will be wrapped in a Template to do variable sharing.
        Passes through all arguments to the _build method, and returns the
        corresponding outputs, plus the name_scope generated by this call of
        the template.
        Args:
          *args: args list for self._build
          **kwargs: kwargs dict for self._build
        Returns:
          A tuple containing (output from _build, scope_name).
        """
        output = self._build(*args, **kwargs)
        # Make a dummy subscope to check the name scope we are in.
        # We could read the name scope from one of the outputs produced,
        # except that the outputs could have been produced from a subscope
        # instantiated by the build function, for example if inner modules
        # are present. Calling name_scope here and creating a new subscope
        # guarantees we get the right answer. Because we don't create an ops
        # inside this dummy scope, no extra memory will be consumed.
        with tf.name_scope("dummy") as scope_name:
            this_scope_name = scope_name[:-len("/dummy/")]
        return output, this_scope_name

    def _check_init_called(self):
        """Checks that the base class's __init__ method has been called.
        Raises:
          NotImplementedError: `AbstractModule.__init__` has not been called.
        """
        try:
            self._template
        except AttributeError:
            raise NotImplementedError(
                "You may have forgotten to call super at the "
                "start of %s.__init__." % self.__class__.__name__)

    @abc.abstractmethod
    def _build(self, *args, **kwargs):
        """Add elements to the Graph, computing output Tensors from input Tensors.
        Subclasses must implement this , which will be wrapped in Template.
        Args:
          *args: Input Tensors.
          **kwargs: Additional Python flags controlling connection.
        Returns:
          output Tensor(s).
        """

    def __call__(self, *args, **kwargs):
        """Operator overload for calling.
        This is the entry point when users connect a Module into the Graph. The
        underlying _build method will have been wrapped in a Template by the
        constructor, and we call this template with the provided inputs here.
        Args:
          *args: Arguments for underlying _build method.
          **kwargs: Keyword arguments for underlying _build method.
        Returns:
          The result of the underlying _build method.
        """
        self._check_init_called()
        outputs, subgraph_name_scope = self._template(*args, **kwargs)
        return outputs

    @property
    def variable_scope(self):
        """Returns the variable_scope declared by the module."""
        return self._template.variable_scope

    @property
    def scope_name(self):
        """Returns the full name of the Module's variable scope."""
        return self._template.variable_scope.name

    @property
    def module_name(self):
        """Returns the name of the Module."""
        return self._unique_name
